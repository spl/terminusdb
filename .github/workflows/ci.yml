name: CI

on:
  push:
    branches:
    tags:
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - LICENSE
  workflow_dispatch:
  workflow_call:

# Prevent redundant workflows triggered by push and pull_request events.
concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:

  # Build the Docker image.
  build_docker:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - uses: falti/dotenv-action@v0.2.7
        id: env
        with:
          log-variables: true

      - name: Build Docker image
        run: |
          docker build . \
            --file Dockerfile \
            --tag ${{ steps.env.outputs.IMAGE_NAME }}:local \
            --build-arg TERMINUSDB_GIT_HASH="$(git rev-parse --verify HEAD)"
          docker save ${{ steps.env.outputs.IMAGE_NAME }}:local \
            | gzip > terminusdb-server-docker-image.tar.gz

      - name: Upload Docker image
        uses: actions/upload-artifact@v2
        with:
            name: terminusdb-server-docker-image
            path: terminusdb-server-docker-image.tar.gz

  lint:
    runs-on: ubuntu-latest
    needs: build_docker
    env:
      SWIPL_LINTER_VERSION: v0.7

    steps:
      - name: Download Docker image
        uses: actions/download-artifact@v2
        with:
          name: terminusdb-server-docker-image

      - uses: falti/dotenv-action@v0.2.7
        id: env

        # Can be found on: https://github.com/terminusdb-labs/swipl-lint/
      - name: Download script
        run: curl -L "https://raw.githubusercontent.com/terminusdb-labs/swipl-lint/$SWIPL_LINTER_VERSION/pl_lint.pl" > pl_lint.pl

      - name: Run linter
        run: |
          docker load < terminusdb-server-docker-image.tar.gz
          docker run \
            --name terminusdb \
            -v $(pwd)/pl_lint.pl:/app/pl_lint.pl \
            ${{ steps.env.outputs.IMAGE_NAME }}:local \
            swipl -f src/load_paths.pl /app/pl_lint.pl

  # Unit tests
  unit_tests:
    runs-on: ubuntu-latest
    needs: build_docker

    steps:
      - name: Download Docker image
        uses: actions/download-artifact@v2
        with:
          name: terminusdb-server-docker-image

      - uses: falti/dotenv-action@v0.2.7
        id: env

      - name: Run unit tests
        run: |
          docker load < terminusdb-server-docker-image.tar.gz
          docker run \
            --name terminusdb \
            ${{ steps.env.outputs.IMAGE_NAME }}:local \
            /app/terminusdb/terminusdb test

  python_integration_tests:
    runs-on: ubuntu-latest
    needs: build_docker

    steps:
      - name: Download Docker image
        uses: actions/download-artifact@v2
        with:
          name: terminusdb-server-docker-image

      - uses: falti/dotenv-action@v0.2.7
        id: env

      - name: Load Docker image
        run: |
          docker load < terminusdb-server-docker-image.tar.gz
          # Tag a dev image because the docker-compose.yml uses
          # a dev tag. We want it to fetch it locally instead of
          # remotely from Docker Hub
          docker image tag \
            ${{ steps.env.outputs.IMAGE_NAME }}:local \
            ${{ steps.env.outputs.IMAGE_NAME }}:dev

      - uses: actions/checkout@v2
        with:
          repository: terminusdb/terminusdb-client-python

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          python -m pip install shed pytest tox
          tox -e deps
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Test with pytest
        run: tox -e test

  # Integration tests
  integration_tests:
    runs-on: ubuntu-latest
    needs: build_docker

    steps:
      - name: Download Docker image
        uses: actions/download-artifact@v2
        with:
          name: terminusdb-server-docker-image

      - uses: falti/dotenv-action@v0.2.7
        id: env

      - name: Run server
        run: |
          docker load < terminusdb-server-docker-image.tar.gz
          docker run \
            --detach \
            --net=host \
            ${{ steps.env.outputs.IMAGE_NAME }}:local

      - uses: actions/setup-node@v2
        with:
          node-version: ${{ steps.env.outputs.NODE_VERSION }}

      - uses: actions/checkout@v2

      - name: Run integration tests
        working-directory: tests
        env:
          TERMINUSDB_DOCKER_IMAGE_TAG: ${{ steps.env.outputs.IMAGE_NAME }}:local
        run: |
          npm install-ci-test
          npm run check

  # Integration tests with insecure user header
  integration_tests_user_header:
    runs-on: ubuntu-latest
    needs: build_docker

    steps:
      - name: Download Docker image
        uses: actions/download-artifact@v2
        with:
          name: terminusdb-server-docker-image

      - uses: falti/dotenv-action@v0.2.7
        id: env

      - name: Run server
        run: |
          docker load < terminusdb-server-docker-image.tar.gz
          docker run \
            --detach \
            --net=host \
            -e TERMINUSDB_INSECURE_USER_HEADER_ENABLED=true \
            -e TERMINUSDB_INSECURE_USER_HEADER='X-Forwarded-User' \
            ${{ steps.env.outputs.IMAGE_NAME }}:local

      - uses: actions/setup-node@v2
        with:
          node-version: ${{ steps.env.outputs.NODE_VERSION }}

      - uses: actions/checkout@v2

      - name: Run integration tests
        working-directory: tests
        env:
          TERMINUSDB_DOCKER_IMAGE_TAG: ${{ steps.env.outputs.IMAGE_NAME }}:local
          TERMINUSDB_INSECURE_USER_HEADER: X-Forwarded-User
        run: |
          npm install-ci-test

  # Integration tests with JWT
  integration_tests_jwt:
    runs-on: ubuntu-latest
    needs: build_docker

    steps:
      - name: Download Docker image
        uses: actions/download-artifact@v2
        with:
          name: terminusdb-server-docker-image

      - uses: falti/dotenv-action@v0.2.7
        id: env

      - name: Run server
        run: |
          docker load < terminusdb-server-docker-image.tar.gz
          docker run \
            --detach \
            --net=host \
            -e TERMINUSDB_JWT_ENABLED=true \
            -e TERMINUSDB_SERVER_JWKS_ENDPOINT='https://cdn.terminusdb.com/jwks.json' \
            ${{ steps.env.outputs.IMAGE_NAME }}:local

      - uses: actions/setup-node@v2
        with:
          node-version: ${{ steps.env.outputs.NODE_VERSION }}

      - uses: actions/checkout@v2

      - name: Run integration tests
        working-directory: tests
        env:
          TERMINUSDB_DOCKER_IMAGE_TAG: ${{ steps.env.outputs.IMAGE_NAME }}:local
          TERMINUSDB_ACCESS_TOKEN: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6InRlc3RrZXkifQ.eyJodHRwOi8vdGVybWludXNkYi5jb20vc2NoZW1hL3N5c3RlbSNhZ2VudF9uYW1lIjoiYWRtaW4iLCJodHRwOi8vdGVybWludXNkYi5jb20vc2NoZW1hL3N5c3RlbSN1c2VyX2lkZW50aWZpZXIiOiJhZG1pbkB1c2VyLmNvbSIsImlzcyI6Imh0dHBzOi8vdGVybWludXNodWIuZXUuYXV0aDAuY29tLyIsInN1YiI6ImFkbWluIiwiYXVkIjpbImh0dHBzOi8vdGVybWludXNodWIvcmVnaXN0ZXJVc2VyIiwiaHR0cHM6Ly90ZXJtaW51c2h1Yi5ldS5hdXRoMC5jb20vdXNlcmluZm8iXSwiaWF0IjoxNTkzNzY5MTgzLCJhenAiOiJNSkpuZEdwMHpVZE03bzNQT1RRUG1SSkltWTJobzBhaSIsInNjb3BlIjoib3BlbmlkIHByb2ZpbGUgZW1haWwifQ.Ru03Bi6vSIQ57bC41n6fClSdxlb61m0xX6Q34Yh91gql0_CyfYRWTuqzqPMFoCefe53hPC5E-eoSFdID_u6w1ih_pH-lTTqus9OWgi07Qou3QNs8UZBLiM4pgLqcBKs0N058jfg4y6h9GjIBGVhX9Ni2ez3JGNcz1_U45BhnreE
        run: |
          npm install-ci-test

  # This is required for status checks.
  all_checks_pass:
    runs-on: ubuntu-latest
    needs:
      - unit_tests
      - integration_tests
      - integration_tests_user_header
      - integration_tests_jwt
      - python_integration_tests
      - lint

    steps:
      - run: echo "Celebrate! ğŸ¥³"

  benchmark:
    runs-on: ubuntu-latest
    needs: build_docker

    steps:
      - name: Download Docker image
        uses: actions/download-artifact@v2
        with:
          name: terminusdb-server-docker-image

      - uses: falti/dotenv-action@v0.2.7
        id: env

      - name: Run server
        run: |
          docker load < terminusdb-server-docker-image.tar.gz
          docker run \
            --detach \
            --net=host \
            ${{ steps.env.outputs.IMAGE_NAME }}:local

      - uses: actions/setup-node@v2
        with:
          node-version: ${{ steps.env.outputs.NODE_VERSION }}

      - uses: actions/checkout@v2

      - name: Run benchmarks
        working-directory: tests
        run: |
          npm ci
          npm run bench

  # Begin deployment only for push events and certain refs.
  #
  # This is an empty job that serves as a common dependency for downstream jobs
  # in their `needs`.
  begin_deploy:
    runs-on: ubuntu-latest
    needs: all_checks_pass
    if: |
      github.repository == 'terminusdb/terminusdb' &&
      github.event_name == 'push' && (
        github.ref == 'refs/heads/main' ||
        startsWith(github.ref, 'refs/tags/v')
      )

    steps:
      - name: Begin deploy
        run: |
          echo "Deploying for:"
          echo "  event: ${{ github.event_name }}"
          echo "  ref:   ${{ github.ref }}"

  # Push Docker image to container repository.
  push_docker:
    runs-on: ubuntu-latest
    needs: begin_deploy

    steps:
      - name: Download Docker image
        uses: actions/download-artifact@v2
        with:
          name: terminusdb-server-docker-image

      - uses: falti/dotenv-action@v0.2.7
        id: env

      - name: Push image to Docker Container Registry
        run: |
          echo '${{ secrets.DOCKER_PASS }}' | docker login -u terminusdb --password-stdin

          # Strip git ref prefix from version
          VERSION=$(echo "$GITHUB_REF" | sed -e 's,.*/\(.*\),\1,')

          # Use Docker `dev` tag convention for main branch
          [ "$VERSION" == "main" ] && VERSION=dev

          docker load < terminusdb-server-docker-image.tar.gz

          # Image identifiers
          LOCAL_IMAGE=${{ steps.env.outputs.IMAGE_NAME }}:local
          VERSION_IMAGE=${{ steps.env.outputs.IMAGE_NAME }}:$VERSION
          DEV_COMMIT_IMAGE=${{ steps.env.outputs.IMAGE_NAME }}:$VERSION-$GITHUB_SHA
          LATEST_IMAGE=${{ steps.env.outputs.IMAGE_NAME }}:latest

          # Tag and push the version image
          docker tag $LOCAL_IMAGE $VERSION_IMAGE
          docker push $VERSION_IMAGE

          # Tag and push the dev-commit image. This is removed later.
          if [ "$VERSION" == "dev" ]; then
            docker tag $LOCAL_IMAGE $DEV_COMMIT_IMAGE
            docker push $DEV_COMMIT_IMAGE
          fi

          # Tag and push the latest image when a version tag is pushed
          if [ $(echo "$GITHUB_REF" | grep "refs/tags/v") ]; then
             docker tag $LOCAL_IMAGE $LATEST_IMAGE
             docker push $LATEST_IMAGE
          fi

  trigger_enterprise_build:
    runs-on: ubuntu-latest
    needs: push_docker
    if: |
      github.repository == 'terminusdb/terminusdb' &&
      github.event_name == 'push' && (
        github.ref == 'refs/heads/main'
      )

    steps:
      - name: Deploy Stage
        run: |
          curl -X POST https://api.github.com/repos/${{ secrets.ENTERPRISE_REPO_OWNER }}/${{ secrets.ENTERPRISE_REPO }}/dispatches \
            -H 'Accept: application/vnd.github.everest-preview+json' \
            -u rrooij:${{ secrets.PAT }} -d '{ "event_type": "Trigger from community" }'
  deploy:
    runs-on: ubuntu-latest
    needs: push_docker
    if: |
      github.repository == 'terminusdb/terminusdb' &&
      github.event_name == 'push' && (
        startsWith(github.ref, 'refs/tags/v')
      )

    steps:
    - uses: actions/checkout@v2

    - name: Set release name
      id: release_name
      run: |
        TAG=$(echo "${{ github.ref }}" | sed -e 's,.*/\(.*\),\1,')
        TAG_WITH_SUFFIX="$TAG"
        echo "::set-output name=tag::$TAG_WITH_SUFFIX"

    - name: Delete tag and release
      uses: dev-drprasad/delete-tag-and-release@v0.1.2
      env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.release_name.outputs.tag }}
      continue-on-error: true

    - name: Create a Release
      id: create_release
      uses: softprops/action-gh-release@v1
      env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.release_name.outputs.tag }}
        prerelease: ${{ !contains(github.ref, 'tags') }}
